#!/usr/bin/env python

import subprocess
import platform
from urllib2 import Request, urlopen, URLError, HTTPError
import urllib
import json
import os, sys, Foundation
import re
import string
import shlex
import shutil
import math

#put your server in here
yourserver = 'http://namer.yourserver.com'


##############
##STOP EDITING
##############
if not os.geteuid()==0:
    sys.exit("\nOnly root can run this script\n")
theurl = yourserver+'/checkin/'
pid = str(os.getpid())
pidfile = "/tmp/checkin.pid"

the_command = "ioreg -c \"IOPlatformExpertDevice\" | awk -F '\"' '/IOPlatformSerialNumber/ {print $4}'"

pid = str(os.getpid())
pidfile = "/tmp/checkin.pid"
if os.path.isfile(pidfile):
    print "%s already exists, exiting" % pidfile
    sys.exit()
else:
    file(pidfile, 'w').write(pid)
serial = subprocess.Popen(the_command,shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE).communicate()[0]
serial = re.sub(r'\s', '', serial)

the_command = "ifconfig | grep \"inet \" | grep -v 127.0.0.1 | cut -d\  -f2"
ip = subprocess.Popen(the_command,shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE).communicate()[0]
ip = re.sub(r'\s', '', ip)
mydata=[('serial',serial),('ip',ip)] 
mydata=urllib.urlencode(mydata)
#print mydata
req = Request(theurl, mydata)
#req.add_header("Content-type", "application/x-www-form-urlencoded")
try:
    response = urlopen(req)
except URLError, e:
    if hasattr(e, 'reason'):
        print 'We failed to reach a server.'
        print 'Reason: ', e.reason
        os.unlink(pidfile)
    elif hasattr(e, 'code'):
        print 'The server couldn\'t fulfill the request'
        print 'Error code: ', e.code
        os.unlink(pidfile)
else:
    #got the data from the server, time to get to work!

    data = response.read()
    data = json.loads(data)
    name = data['name']
    prefix = data['prefix']
    domain = data['domain']
    length = data['length']

    if name:
        ##there's a name there, now to see if we need to exit
        theprocess = "scutil --get ComputerName"
        oldname = subprocess.Popen(theprocess,shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE).communicate()[0]
        oldname = oldname.strip()
        if prefix:
            newname = prefix+' '+name
        else:
            newname = name
        if newname == oldname:
            print 'No change to name, exiting'
            need_change = False
        else:
            need_change = True
        if prefix:
            #is a prefix set? if so, we need to pad the zeroes
            name = name.zfill(length)
        #the hostname must be set
        #if there's a prefix, add that to the name
        #set the local hostname
        if prefix:
            localname = prefix.replace(' ', '-') + "-" + name.replace(' ', '-')
        else:
            localname = name.replace(' ', '-')
        
        ##do we need to change the name?
        if need_change == True:
            localname=re.sub("[^0-9a-zA-Z\-]","",localname)
            theprocess = "scutil --set LocalHostName" + " " +localname
            p = subprocess.Popen(theprocess,shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE).communicate()[0]
        #set the bonjour name
            if prefix:
                theprocess = "scutil --set ComputerName" + " \"" + prefix  + " " +name + "\""
            else:
                theprocess = "scutil --set ComputerName" + " \"" +name + "\""
            p = subprocess.Popen(theprocess,shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE).communicate()[0]
        
        ##if a domain is set, set the full hostname
        if domain:
            theprocess = "scutil --get HostName"
            oldhostname = subprocess.Popen(theprocess,shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE).communicate()[0].strip()
            if oldhostname == localname+"."+domain:
                print "Hostname is the same, no need to change"
            else:
                theprocess = "scutil --set HostName" + " " +localname+"."+domain
                p = subprocess.Popen(theprocess,shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE).communicate()[0]
        #we're done
        os.unlink(pidfile)